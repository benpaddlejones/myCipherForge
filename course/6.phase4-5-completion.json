{
  "id": "phase4-5-completion",
  "title": "Phases 4 & 5: Noise Injection and Your Wild Card",
  "sections": [
    {
      "type": "markdown",
      "content": {
        "text": "# Lesson 6: Phases 4 & 5 \u2014 Noise Injection and Your Wild Card\n\n### Learning Objectives\n\nBy the end of this lesson, you will:\n\n- Implement Phase 4: Add decoy noise characters\n- Design Phase 5: Your own unique encryption layer\n- Complete the full 5-phase encryption algorithm\n- Understand how layered encryption defeats multiple attack types\n\n---\n\n## The Problem with Frequency Analysis\n\nEven with password-based encryption, attackers can still study **how often** each character appears:\n\n```\nCiphertext: \"x~S#{&\u20acmzux~x~S#{&\u20acmzux~\"\n```\n\nIf `~` appears 4 times and `#` appears 2 times, those patterns leak information.\n\n**Solution**: Add **noise** \u2014 throw in random characters that mean nothing!"
      }
    },
    {
      "type": "mcq",
      "title": "Noise Purpose",
      "content": {
        "question": "What security benefit does adding noise characters provide?",
        "options": [
          "Makes encryption faster",
          "Flattens character frequency patterns, confusing statistical analysis",
          "Compresses the message",
          "Makes the password stronger"
        ],
        "correct_index": 1,
        "explanation": "Noise injection adds decoy characters throughout the ciphertext. If an attacker counts how often each character appears (frequency analysis), the noise characters dilute the real patterns, making statistical attacks much harder."
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 1: Add Phase 4 Functions\n\nPhase 4 inserts a **noise character** after every N characters. The key dictionary will tell us:\n\n- `noise_interval` \u2014 insert noise every N characters\n- `noise_char` \u2014 which character to insert (e.g., `~`)\n\n**Add this code to `engine.py`** (after your Phase 3 functions):\n\n```python\n###############################################\n# PHASE 4: NOISE INJECTION\n###############################################\n\ndef phase4_encrypt(text, key):\n    \"\"\"Insert noise character every N positions.\"\"\"\n    interval = key.get(\"noise_interval\", 3)\n    noise = key.get(\"noise_char\", \"~\")\n    \n    result = \"\"\n    count = 0\n    \n    for char in text:\n        result += char\n        count += 1\n        # Insert noise after every N real characters\n        if count % interval == 0:\n            result += noise\n    \n    return result\n\n\ndef phase4_decrypt(text, key):\n    \"\"\"Remove noise characters at their known positions.\"\"\"\n    interval = key.get(\"noise_interval\", 3)\n    \n    result = \"\"\n    real_count = 0\n    i = 0\n    \n    while i < len(text):\n        result += text[i]\n        real_count += 1\n        i += 1\n        \n        # Skip the noise character after every N real characters\n        if real_count % interval == 0 and i < len(text):\n            i += 1  # Skip noise\n    \n    return result\n```\n\n### Save and Test in the Terminal\n\n```python\nfrom engine import phase4_encrypt, phase4_decrypt\n\nkey = {\"shift\": 5, \"block_size\": 4, \"password\": \"SECRET\", \"noise_interval\": 3, \"noise_char\": \"~\"}\n\ntest = \"HELLO WORLD\"\nnoisy = phase4_encrypt(test, key)\nprint(f\"Original:  {test}\")\nprint(f\"With noise: {noisy}\")\nprint(f\"Cleaned:   {phase4_decrypt(noisy, key)}\")\n```\n\nExpected output:\n```\nOriginal:  HELLO WORLD\nWith noise: HEL~LO ~WOR~LD\nCleaned:   HELLO WORLD\n```"
      }
    },
    {
      "type": "mcq",
      "title": "Noise Position",
      "content": {
        "question": "With `noise_interval = 3` and `noise_char = \"~\"`, what happens to the string `\"ABCDEF\"`?",
        "options": [
          "ABC~DEF~",
          "~ABC~DEF",
          "A~B~C~D~E~F",
          "ABCDEF~"
        ],
        "correct_index": 0,
        "explanation": "With interval=3, noise is inserted AFTER every 3rd character. After 'C' (position 3), insert `~`. After 'F' (position 6), insert `~`. Result: `ABC~DEF~`."
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 2: Update Master Functions for Phase 4\n\nNow add Phase 4 to your master `encrypt()` and `decrypt()` functions.\n\n**Update the `encrypt()` function** \u2014 add Phase 4 AFTER Phase 3:\n\n```python\ndef encrypt(plaintext, key):\n    \"\"\"Apply all encryption phases in sequence.\"\"\"\n    result = plaintext\n    \n    # Phase 1: Substitution (shift all characters)\n    result = phase1_encrypt(result, key)\n    \n    # Phase 2: Transposition (reverse blocks)\n    result = phase2_encrypt(result, key)\n    \n    # Phase 3: Key-dependent (password-based variable shift)\n    result = phase3_encrypt(result, key)\n    \n    # Phase 4: Noise injection (add decoy characters)\n    result = phase4_encrypt(result, key)\n    \n    # TODO: Phase 5 - Wild Card (your invention!)\n    \n    return result\n```\n\n**Update the `decrypt()` function** \u2014 Phase 4 runs FIRST (remember: reverse order!):\n\n```python\ndef decrypt(ciphertext, key):\n    \"\"\"Reverse all encryption phases.\"\"\"\n    result = ciphertext\n    \n    # Decrypt in REVERSE order!\n    \n    # TODO: Phase 5 - Wild Card (your invention!)\n    \n    # Phase 4: Remove noise characters\n    result = phase4_decrypt(result, key)\n    \n    # Phase 3: Reverse password-based shift\n    result = phase3_decrypt(result, key)\n    \n    # Phase 2: Reverse transposition (self-inverse)\n    result = phase2_decrypt(result, key)\n    \n    # Phase 1: Reverse substitution (shift back)\n    result = phase1_decrypt(result, key)\n    \n    return result\n```"
      }
    },
    {
      "type": "mcq",
      "title": "Decrypt Order",
      "content": {
        "question": "If encryption order is: Phase1 \u2192 Phase2 \u2192 Phase3 \u2192 Phase4, what is the correct decryption order?",
        "options": [
          "Phase1 \u2192 Phase2 \u2192 Phase3 \u2192 Phase4",
          "Phase4 \u2192 Phase3 \u2192 Phase2 \u2192 Phase1",
          "Phase4 \u2192 Phase1 \u2192 Phase2 \u2192 Phase3",
          "Phase3 \u2192 Phase4 \u2192 Phase1 \u2192 Phase2"
        ],
        "correct_index": 1,
        "explanation": "Decryption must reverse the encryption in EXACT reverse order. Think of it like unwrapping layers \u2014 the last layer wrapped on is the first layer removed. Phase 4 was applied last in encryption, so it must be removed first in decryption."
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 3: Test the 4-Phase Pipeline\n\nLet's verify everything works together:\n\n```python\nfrom engine import encrypt, decrypt\n\nkey = {\n    \"shift\": 5,\n    \"block_size\": 4,\n    \"password\": \"CIPHER\",\n    \"noise_interval\": 3,\n    \"noise_char\": \"~\"\n}\n\nmessage = \"The eagle lands at midnight\"\nprint(f\"Original:  {message}\")\n\nencrypted = encrypt(message, key)\nprint(f\"Encrypted: {encrypted}\")\n\ndecrypted = decrypt(encrypted, key)\nprint(f\"Decrypted: {decrypted}\")\n\nprint(f\"\\nMatch: {message == decrypted}\")\n```\n\nIf `Match: True`, your 4-phase algorithm works!\n\n**If it fails**: Check that Phase 4 is in the correct position in both functions. Encryption adds Phase 4 LAST. Decryption removes it FIRST."
      }
    },
    {
      "type": "written_response",
      "title": "Phase 4 Verification",
      "content": {
        "description": "Run the 4-phase pipeline test above. Copy and paste your terminal output showing the Original, Encrypted, Decrypted, and Match results. Does your algorithm correctly round-trip?",
        "example_answer": "Original:  The eagle lands at midnight\nEncrypted: d~m\\#c~`|fle~lzlr~fvlkv~dxql~\nDecrypted: The eagle lands at midnight\n\nMatch: True\n\nThe algorithm correctly round-trips! The encrypted text is longer because of the noise characters (~) inserted every 3 characters.",
        "min_words": 30
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "---\n\n## Phase 5: Your Wild Card! \ud83c\udccf\n\nNow comes the creative part \u2014 **you design Phase 5**!\n\n### Rules for Phase 5\n\n1. **Must be reversible** \u2014 `decrypt(encrypt(x)) == x`\n2. **Must be original** \u2014 different from Phases 1-4\n3. **Must use code** \u2014 not just a renamed copy of another phase\n\n### Ideas to Inspire You\n\n**Idea A: Pair Swapping**\n```python\n# Swap every two adjacent characters\n\"ABCDEF\" \u2192 \"BADCFE\"\n# Reversal: swap again!\n```\n\n**Idea B: Alternating Direction**\n```python\n# Even positions: shift forward by 7\n# Odd positions: shift backward by 7\nfor i, char in enumerate(text):\n    pos = ord(char) - 32\n    if i % 2 == 0:\n        new_pos = (pos + 7) % 95\n    else:\n        new_pos = (pos - 7) % 95\n```\n\n**Idea C: Bit Flip (XOR)**\n```python\n# XOR each character code with a value\nfor char in text:\n    flipped = ord(char) ^ 42  # XOR with 42\n    result += chr(flipped)\n# Reversal: XOR again with same value!\n```\n\n**Idea D: Reverse the Whole String**\n```python\n# Simple but effective!\nresult = text[::-1]\n# Reversal: reverse again!\n```\n\n**Idea E: Add Position-Based Shift**\n```python\n# Each character shifted by its position\nfor i, char in enumerate(text):\n    pos = ord(char) - 32\n    shifted = (pos + i) % 95\n    result += chr(shifted + 32)\n```"
      }
    },
    {
      "type": "written_response",
      "title": "Phase 5 Design",
      "content": {
        "description": "Before writing code, PLAN your Phase 5 encryption layer. Describe:\n\n1. What technique will you use? (Give it a name!)\n2. How does encryption work? (Step by step)\n3. How does decryption reverse it?\n4. Why is it reversible?\n\nBe specific enough that someone else could implement it from your description.",
        "example_answer": "My Phase 5 is called 'Mirror Swap'.\n\nEncryption: I split the text into halves and swap them. For 'HELLO WORLD', I get 'HELLO' and ' WORLD', then join them as ' WORLDHELLO'.\n\nDecryption: I do the exact same operation \u2014 split in half and swap. ' WORLDHELLO' becomes 'HELLO' and ' WORLD', joined as 'HELLO WORLD'.\n\nThis is reversible because swapping halves twice returns to the original. It's a self-inverse operation like Phase 2's block reversal.",
        "min_words": 50
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 4: Implement Your Phase 5\n\n**Add your Phase 5 functions to `engine.py`**. Here's the template:\n\n```python\n###############################################\n# PHASE 5: WILD CARD - [YOUR NAME HERE]\n###############################################\n\ndef phase5_encrypt(text, key):\n    \"\"\"[Describe what your phase does].\"\"\"\n    result = \"\"\n    \n    # YOUR ENCRYPTION CODE HERE\n    \n    return result\n\n\ndef phase5_decrypt(text, key):\n    \"\"\"[Describe how you reverse it].\"\"\"\n    result = \"\"\n    \n    # YOUR DECRYPTION CODE HERE\n    \n    return result\n```\n\n### Example: Pair Swapping Implementation\n\nIf you chose pair swapping, here's how it might look:\n\n```python\ndef phase5_encrypt(text, key):\n    \"\"\"Swap adjacent character pairs.\"\"\"\n    result = \"\"\n    \n    for i in range(0, len(text) - 1, 2):\n        # Swap pairs: AB \u2192 BA\n        result += text[i + 1]\n        result += text[i]\n    \n    # Handle odd-length strings (last char stays)\n    if len(text) % 2 == 1:\n        result += text[-1]\n    \n    return result\n\n\ndef phase5_decrypt(text, key):\n    \"\"\"Swapping twice returns original \u2014 self-inverse!\"\"\"\n    return phase5_encrypt(text, key)  # Same operation!\n```\n\n### Test Your Phase 5 in Isolation\n\n```python\nfrom engine import phase5_encrypt, phase5_decrypt\n\ntest = \"Hello World!\"\nencrypted = phase5_encrypt(test, {})\nprint(f\"Original:  {test}\")\nprint(f\"Phase 5:   {encrypted}\")\nprint(f\"Reversed:  {phase5_decrypt(encrypted, {})}\")\nprint(f\"Match:     {test == phase5_decrypt(encrypted, {})}\")\n```\n\n**Do NOT continue until `Match: True`!**"
      }
    },
    {
      "type": "python",
      "title": "Phase 5 Implementation",
      "content": {
        "description": "Implement YOUR Phase 5 encryption and decryption functions. You can use one of the ideas provided or create your own. The key requirement: decrypt(encrypt(text)) must return the original text.\n\nTest your implementation to verify it's reversible.",
        "starter_code": "# PHASE 5: WILD CARD - [Give it a name!]\n\ndef phase5_encrypt(text, key):\n    \"\"\"[Your description here].\"\"\"\n    result = \"\"\n    \n    # YOUR ENCRYPTION CODE HERE\n    \n    return result\n\n\ndef phase5_decrypt(text, key):\n    \"\"\"[Your description here].\"\"\"\n    result = \"\"\n    \n    # YOUR DECRYPTION CODE HERE\n    \n    return result\n\n\n# Test your implementation\ntest = \"The quick brown fox jumps!\"\nencrypted = phase5_encrypt(test, {})\ndecrypted = phase5_decrypt(encrypted, {})\n\nprint(f\"Original:  {test}\")\nprint(f\"Encrypted: {encrypted}\")\nprint(f\"Decrypted: {decrypted}\")\nprint(f\"Match:     {test == decrypted}\")",
        "example_answer": "# PHASE 5: WILD CARD - Pair Swap\n\ndef phase5_encrypt(text, key):\n    \"\"\"Swap adjacent character pairs.\"\"\"\n    result = \"\"\n    \n    for i in range(0, len(text) - 1, 2):\n        result += text[i + 1]  # Second char first\n        result += text[i]      # First char second\n    \n    if len(text) % 2 == 1:\n        result += text[-1]  # Odd char stays\n    \n    return result\n\n\ndef phase5_decrypt(text, key):\n    \"\"\"Self-inverse \u2014 same operation reverses it.\"\"\"\n    return phase5_encrypt(text, key)\n\n\ntest = \"The quick brown fox jumps!\"\nencrypted = phase5_encrypt(test, {})\ndecrypted = phase5_decrypt(encrypted, {})\n\nprint(f\"Original:  {test}\")\nprint(f\"Encrypted: {encrypted}\")\nprint(f\"Decrypted: {decrypted}\")\nprint(f\"Match:     {test == decrypted}\")",
        "min_lines": 10
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 5: Complete the Master Functions\n\n**Update `encrypt()`** \u2014 add Phase 5:\n\n```python\ndef encrypt(plaintext, key):\n    \"\"\"Apply all 5 encryption phases in sequence.\"\"\"\n    result = plaintext\n    \n    # Phase 1: Substitution (shift all characters)\n    result = phase1_encrypt(result, key)\n    \n    # Phase 2: Transposition (reverse blocks)\n    result = phase2_encrypt(result, key)\n    \n    # Phase 3: Key-dependent (password-based variable shift)\n    result = phase3_encrypt(result, key)\n    \n    # Phase 4: Noise injection (add decoy characters)\n    result = phase4_encrypt(result, key)\n    \n    # Phase 5: Wild Card (your invention!)\n    result = phase5_encrypt(result, key)\n    \n    return result\n```\n\n**Update `decrypt()`** \u2014 Phase 5 runs FIRST:\n\n```python\ndef decrypt(ciphertext, key):\n    \"\"\"Reverse all 5 encryption phases.\"\"\"\n    result = ciphertext\n    \n    # Decrypt in REVERSE order!\n    \n    # Phase 5: Reverse your wild card\n    result = phase5_decrypt(result, key)\n    \n    # Phase 4: Remove noise characters\n    result = phase4_decrypt(result, key)\n    \n    # Phase 3: Reverse password-based shift\n    result = phase3_decrypt(result, key)\n    \n    # Phase 2: Reverse transposition (self-inverse)\n    result = phase2_decrypt(result, key)\n    \n    # Phase 1: Reverse substitution (shift back)\n    result = phase1_decrypt(result, key)\n    \n    return result\n```"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 6: The Final Test \u2014 Full 5-Phase Pipeline\n\nThis is the moment of truth! Run this comprehensive test:\n\n```python\nfrom engine import encrypt, decrypt\n\nkey = {\n    \"shift\": 7,\n    \"block_size\": 5,\n    \"password\": \"SECRETKEY\",\n    \"noise_interval\": 4,\n    \"noise_char\": \"$\"\n}\n\ntest_messages = [\n    \"Hello World!\",\n    \"The quick brown fox jumps over the lazy dog.\",\n    \"CipherForge 2026 - Encryption Complete!\",\n    \"abc123!@#\",\n    \"A\",\n    \"\"\n]\n\nprint(\"=\"*60)\nprint(\"CIPHERFORGE 5-PHASE ENCRYPTION TEST\")\nprint(\"=\"*60)\n\nall_passed = True\nfor msg in test_messages:\n    encrypted = encrypt(msg, key)\n    decrypted = decrypt(encrypted, key)\n    passed = (msg == decrypted)\n    status = \"\u2705\" if passed else \"\u274c\"\n    print(f\"{status} '{msg[:30]}...' \u2192 Match: {passed}\")\n    if not passed:\n        all_passed = False\n        print(f\"   Got: '{decrypted}'\")\n\nprint(\"=\"*60)\nif all_passed:\n    print(\"\ud83c\udf89 ALL TESTS PASSED! Your 5-phase algorithm is complete!\")\nelse:\n    print(\"\u26a0\ufe0f  Some tests failed. Debug your phases.\")\nprint(\"=\"*60)\n```"
      }
    },
    {
      "type": "written_response",
      "title": "Final Test",
      "content": {
        "description": "Run the full 5-phase pipeline test above. Copy and paste your terminal output. Did all tests pass? If any failed, explain what you did to fix them.",
        "example_answer": "============================================================\nCIPHERFORGE 5-PHASE ENCRYPTION TEST\n============================================================\n\u2705 'Hello World!...' \u2192 Match: True\n\u2705 'The quick brown fox jumps ove...' \u2192 Match: True\n\u2705 'CipherForge 2026 - Encryption...' \u2192 Match: True\n\u2705 'abc123!@#...' \u2192 Match: True\n\u2705 'A...' \u2192 Match: True\n\u2705 '...' \u2192 Match: True\n============================================================\n\ud83c\udf89 ALL TESTS PASSED! Your 5-phase algorithm is complete!\n============================================================\n\nAll 6 tests passed on the first try!",
        "min_words": 30
      }
    },
    {
      "type": "mcq",
      "title": "Key Space",
      "content": {
        "question": "Your complete algorithm has: 95 shift values \u00d7 20 block sizes \u00d7 95^9 password combinations \u00d7 variable noise. Approximately how many key combinations exist?",
        "options": [
          "About 1 million",
          "About 1 billion",
          "About 1 quadrillion (10^15)",
          "More than 10^20 (hundred quintillion)"
        ],
        "correct_index": 3,
        "explanation": "The key space is: 95 \u00d7 20 \u00d7 95^9 = 1,900 \u00d7 630,249,409,724,609,375 \u2248 1.2 \u00d7 10^21 (over a sextillion combinations!). This is why layered encryption with multiple key parts is so powerful \u2014 each layer multiplies the total possibilities."
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "---\n\n## Checkpoint: Commit Your Completed Algorithm\n\n```bash\ngit add -A\ngit commit -m \"feat: Complete 5-phase encryption algorithm\"\ngit push\n```\n\n---\n\n## Code Progress Summary\n\nYour `engine.py` now contains the complete algorithm:\n\n| Function | Purpose | Status |\n|----------|---------|--------|\n| `phase1_encrypt()` | Caesar shift | \u2705 |\n| `phase1_decrypt()` | Reverse shift | \u2705 |\n| `phase2_encrypt()` | Block reversal | \u2705 |\n| `phase2_decrypt()` | Block reversal (self-inverse) | \u2705 |\n| `phase3_encrypt()` | Password-based variable shift | \u2705 |\n| `phase3_decrypt()` | Reverse password shift | \u2705 |\n| `phase4_encrypt()` | Noise injection | \u2705 |\n| `phase4_decrypt()` | Remove noise | \u2705 |\n| `phase5_encrypt()` | Your wild card | \u2705 |\n| `phase5_decrypt()` | Reverse wild card | \u2705 |\n| `encrypt()` | Master encrypt (all 5 phases) | \u2705 |\n| `decrypt()` | Master decrypt (reverse order) | \u2705 |\n\n### Your Algorithm is Complete!\n\nYou've built a **5-layer encryption system** that:\n\n- Takes plaintext and a secret key\n- Applies 5 different transformations\n- Produces unreadable ciphertext\n- Perfectly reverses with the correct key\n- Has over 10^20 possible key combinations\n\n---\n\n## What You've Accomplished\n\n| Phase | Type | Attack It Defeats |\n|-------|------|-------------------|\n| 1 | Substitution | Simple letter comparison |\n| 2 | Transposition | Position-based attacks |\n| 3 | Key-Dependent | Brute force (exponential keys) |\n| 4 | Noise | Frequency analysis |\n| 5 | Wild Card | Your unique contribution! |\n\nYou now understand the same **layered approach** used by professional encryption like AES!\n\n---\n\n## Next Lesson Preview\n\nIn **Lesson 7: Building the Flask Web Interface**, you'll:\n\n- Create Flask routes for encryption and decryption\n- Build HTML forms for user input\n- Connect your algorithm to a real web application\n- Test encryption through a browser interface\n\nYour algorithm works \u2014 now let's make it accessible!"
      }
    }
  ]
}