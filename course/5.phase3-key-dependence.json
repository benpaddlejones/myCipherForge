{
  "id": "phase3-key-dependence",
  "title": "Phase 3: Password-Based Encryption",
  "description": "Make your encryption depend on a secret password! Learn how password-based shifting creates billions of possible keys, making brute force attacks impractical.",
  "sections": [
    {
      "type": "markdown",
      "content": {
        "text": "## Learning Objectives\n\n- Understand why fixed encryption rules are weak\n- Implement `phase3_encrypt()` using password-based variable shifting\n- Implement `phase3_decrypt()` that requires the same password\n- Update the master `encrypt()` and `decrypt()` functions\n- Calculate key space size and understand exponential growth\n- Test that wrong passwords produce garbage output\n- Commit your Phase 3 implementation\n\n---\n\n## \ud83d\udd11 The Missing Ingredient: A Secret Password\n\nYour algorithm has two layers now, but there's a problem:\n\n**Everyone using your algorithm with the same settings gets the same output!**\n\nIn this lesson, you'll add Phase 3: **Password-dependent encryption**. This makes your cipher unique to each user's secret password \u2014 and creates **billions** of possible keys!"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## The Problem with Fixed Rules\n\n### Current Situation (Phases 1-2)\n\nRight now, if two people use the same shift and block_size:\n\n```python\n# Alice encrypts a message\nalice_key = {\"shift\": 7, \"block_size\": 4}\nalice_cipher = encrypt(\"Secret!\", alice_key)  # \u2192 \"jlZy!{\"\n\n# Bob encrypts the same message with same settings\nbob_key = {\"shift\": 7, \"block_size\": 4}\nbob_cipher = encrypt(\"Secret!\", bob_key)      # \u2192 \"jlZy!{\"  \u2190 SAME!\n```\n\n### Why This Is Bad\n\n| Problem | Impact |\n|---------|---------|\n| **Predictable** | Same message always looks identical |\n| **No personalization** | Can't choose your own password |\n| **Easy to crack** | Only 1,900 combinations to try |\n\n### The Solution: Add a Password!\n\n```python\n# Alice encrypts with password \"DRAGON\"\nalice_key = {\"shift\": 7, \"block_size\": 4, \"password\": \"DRAGON\"}\nalice_cipher = encrypt(\"Secret!\", alice_key)  # \u2192 \"x!Rm#p\"\n\n# Bob encrypts with password \"PHOENIX\"\nbob_key = {\"shift\": 7, \"block_size\": 4, \"password\": \"PHOENIX\"}\nbob_cipher = encrypt(\"Secret!\", bob_key)      # \u2192 \"k$Wq&t\"  \u2190 DIFFERENT!\n```\n\n**Same message + different passwords = Different ciphertexts!** \u2705"
      }
    },
    {
      "type": "mcq",
      "title": "Why Passwords Matter",
      "content": {
        "question": "Why does adding a password to encryption make it more secure?",
        "options": [
          "Passwords make the code run faster",
          "Different passwords create different outputs, even for the same message",
          "Passwords make the encrypted text shorter",
          "Passwords are required by law"
        ],
        "correct_index": 1,
        "explanation": "Password-based encryption means that even if an attacker knows your algorithm and some settings, they still can't decrypt without the password. Every different password creates completely different ciphertext, making each user's encryption unique and independent."
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## How Password-Based Shifting Works\n\nInstead of using the same shift for every character (Phase 1), we'll use the **password to determine a different shift for each position**.\n\n### The Concept\n\n```\nMessage:   H   E   L   L   O\nPassword:  C   A   T   C   A   (repeats if message is longer)\nShift:    67  65  84  67  65   (ASCII value of password character)\n```\n\nEach character gets shifted by a **different amount** based on the password!\n\n### Why This Is Powerful\n\n**Phase 1 (fixed shift):**\n\n- All `E`s become the same letter\n- Pattern: Easy to spot with frequency analysis\n\n**Phase 3 (variable shift):**\n\n- Each `E` might become a different letter\n- Pattern: Destroyed! Frequency analysis fails!\n\n### The Formula\n\nFor each character at position `i`:\n\n```python\npassword_char = password[i % len(password)]  # Repeat password\nshift_amount = ord(password_char) % 95       # Convert to 0-94 range\n# Apply shift_amount to the character\n```"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## \ud83e\uddea Experiment: See the Pattern\n\nBefore coding Phase 3, let's understand how password-based shifts work.\n\n### Open Python REPL\n\n```bash\npython\n```\n\n### See How Password Creates Shifts\n\n```python\npassword = \"CAT\"\n\n# Calculate shift for each position in a 10-character message\nfor i in range(10):\n    password_char = password[i % len(password)]  # Cycles: C, A, T, C, A, T...\n    shift = ord(password_char) % 95\n    print(f\"Position {i}: password char '{password_char}' \u2192 shift {shift}\")\n```\n\n### Expected Output\n\n```\nPosition 0: password char 'C' \u2192 shift 67\nPosition 1: password char 'A' \u2192 shift 65\nPosition 2: password char 'T' \u2192 shift 84\nPosition 3: password char 'C' \u2192 shift 67\nPosition 4: password char 'A' \u2192 shift 65\n...\n```\n\n### Try Different Passwords\n\n```python\npassword = \"SECRET\"\nfor i in range(6):\n    pc = password[i % len(password)]\n    print(f\"'{pc}' \u2192 {ord(pc) % 95}\")\n```\n\n### Exit Python\n\n```python\nexit()\n```"
      }
    },
    {
      "type": "mcq",
      "title": "Password Cycling",
      "content": {
        "question": "If the password is 'AB' and the message is 'HELLO', which password character is used for position 4 (the 'O')?",
        "options": [
          "A (because 4 is even)",
          "B (because 4 is odd)",
          "A (because 4 % 2 = 0, and password[0] = 'A')",
          "Neither \u2014 the password is too short"
        ],
        "correct_index": 2,
        "explanation": "The password repeats: positions 0,2,4,6... use password[0]='A', and positions 1,3,5,7... use password[1]='B'. For position 4: 4 % 2 = 0, so we use password[0] = 'A'. The password cycles through as many times as needed!"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 1: Add Phase 3 Encrypt\n\nOpen `engine.py` in Codespaces.\n\n### Add This Function After phase2_decrypt\n\nType this new function:\n\n```python\ndef phase3_encrypt(text, key):\n    \"\"\"\n    Phase 3: Password-Dependent \u2014 Variable shifts based on password.\n    \n    Each character is shifted by a different amount determined by\n    the corresponding character in the repeating password.\n    This destroys frequency patterns!\n    \n    Args:\n        text: The string to transform (already Phase 1+2 encrypted)\n        key: Dictionary containing encryption settings\n        \n    Returns:\n        The password-encrypted string\n    \"\"\"\n    # Get password from key (default to \"SECRET\" if not specified)\n    password = key.get(\"password\", \"SECRET\")\n    \n    result = \"\"\n    \n    for i, char in enumerate(text):\n        if 32 <= ord(char) <= 126:\n            # Get the password character for this position (cycling)\n            password_char = password[i % len(password)]\n            # Calculate shift from password character\n            password_shift = ord(password_char) % 95\n            \n            # Apply the shift (same math as Phase 1)\n            position = ord(char) - 32\n            new_position = (position + password_shift) % 95\n            result += chr(new_position + 32)\n        else:\n            result += char\n    \n    return result\n```\n\n### Understanding the Code\n\n| Line | What It Does |\n|------|--------------|\n| `password[i % len(password)]` | Cycles through password characters |\n| `ord(password_char) % 95` | Converts password char to shift (0-94) |\n| `(position + password_shift) % 95` | Applies variable shift with wrapping |\n\n### Save the File (Ctrl + S)"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 2: Add Phase 3 Decrypt\n\nDecryption uses the same password but **subtracts** the shifts.\n\n### Add This Function Below phase3_encrypt\n\n```python\ndef phase3_decrypt(text, key):\n    \"\"\"\n    Phase 3: Reverse the password-dependent encryption.\n    \n    CRITICAL: Must use the SAME password that was used for encryption!\n    Wrong password = garbage output.\n    \n    Args:\n        text: The encrypted string\n        key: Dictionary with the SAME password used for encryption\n        \n    Returns:\n        The decrypted string (if password is correct)\n    \"\"\"\n    password = key.get(\"password\", \"SECRET\")\n    \n    result = \"\"\n    \n    for i, char in enumerate(text):\n        if 32 <= ord(char) <= 126:\n            # Get same password character for this position\n            password_char = password[i % len(password)]\n            password_shift = ord(password_char) % 95\n            \n            # SUBTRACT the shift to reverse encryption\n            position = ord(char) - 32\n            new_position = (position - password_shift) % 95\n            result += chr(new_position + 32)\n        else:\n            result += char\n    \n    return result\n```\n\n### The Only Difference\n\n```python\n# Encrypt: ADD the shift\nnew_position = (position + password_shift) % 95\n\n# Decrypt: SUBTRACT the shift\nnew_position = (position - password_shift) % 95\n```\n\n### Save the File"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 3: Test Phase 3 Alone\n\nBefore integrating, let's test Phase 3 by itself.\n\n### Open Python REPL\n\n```bash\npython\n```\n\n### Test with Correct Password\n\n```python\nfrom engine import phase3_encrypt, phase3_decrypt\n\nkey = {\"password\": \"DRAGON\"}\n\nmessage = \"Hello World!\"\nprint(f\"Original: {message}\")\n\nencrypted = phase3_encrypt(message, key)\nprint(f\"Encrypted: {encrypted}\")\n\ndecrypted = phase3_decrypt(encrypted, key)\nprint(f\"Decrypted: {decrypted}\")\n\nprint(f\"Match: {decrypted == message}\")\n```\n\n### Test with WRONG Password\n\n```python\n# Encrypt with \"DRAGON\"\nkey_dragon = {\"password\": \"DRAGON\"}\nencrypted = phase3_encrypt(\"Secret!\", key_dragon)\n\n# Try to decrypt with \"UNICORN\" (wrong!)\nkey_unicorn = {\"password\": \"UNICORN\"}\nwrong_decrypt = phase3_decrypt(encrypted, key_unicorn)\n\nprint(f\"Encrypted: {encrypted}\")\nprint(f\"Wrong password decrypt: {wrong_decrypt}\")\nprint(\"See? Wrong password = garbage!\")\n```\n\n### Try Different Passwords on Same Message\n\n```python\npasswords = [\"cat\", \"CAT\", \"DOG\", \"password123\"]\nmessage = \"Same message\"\n\nfor pw in passwords:\n    key = {\"password\": pw}\n    encrypted = phase3_encrypt(message, key)\n    print(f\"Password '{pw}': {encrypted}\")\n```\n\n### Exit Python\n\n```python\nexit()\n```"
      }
    },
    {
      "type": "written_response",
      "title": "Wrong Password Test",
      "content": {
        "description": "Encrypt a message with one password, then try to decrypt it with a DIFFERENT password. Record: (1) your original message, (2) the password used for encryption, (3) the encrypted result, (4) the wrong password you tried, (5) what the wrong-password decryption produced. Why is this behavior actually a security feature?",
        "example_answer": "Original: 'Top Secret!'\nEncryption password: 'MYSECRET'\nEncrypted: 'Z!#k2m&*pQ'\nWrong password tried: 'NOTMYSECRET'\nWrong decrypt result: 'Hj*m@!zLpp' (complete garbage)\n\nThis is a security feature because even if an attacker knows the algorithm, they can't decrypt without the correct password. The wrong password produces meaningless output, giving no clues about the original message.",
        "min_words": 40,
        "max_words": 150
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 4: Update Master Encrypt Function\n\nNow integrate Phase 3 into the encryption pipeline.\n\n### Find and Update encrypt()\n\nChange your `encrypt()` function to:\n\n```python\ndef encrypt(text, key):\n    \"\"\"\n    CipherForge Master Encryption \u2014 Applies all 5 phases.\n    \n    Currently implemented: Phases 1-3\n    Coming soon: Phases 4-5\n    \"\"\"\n    # Phase 1: Substitution \u2014 change WHAT characters are\n    result = phase1_encrypt(text, key)\n    \n    # Phase 2: Transposition \u2014 change WHERE characters are\n    result = phase2_encrypt(result, key)\n    \n    # Phase 3: Password-Dependent \u2014 destroy frequency patterns\n    result = phase3_encrypt(result, key)\n    \n    # TODO: Phase 4 \u2014 Noise Injection\n    # result = phase4_encrypt(result, key)\n    \n    # TODO: Phase 5 \u2014 Wild Card\n    # result = phase5_encrypt(result, key)\n    \n    return result\n```\n\n### Save the File"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 5: Update Master Decrypt Function\n\nRemember: Decrypt in **reverse order**!\n\n### Find and Update decrypt()\n\n```python\ndef decrypt(text, key):\n    \"\"\"\n    CipherForge Master Decryption \u2014 Reverses all 5 phases.\n    \n    CRITICAL: Phases reversed in OPPOSITE order!\n    Encrypt: 1 \u2192 2 \u2192 3 \u2192 4 \u2192 5\n    Decrypt: 5 \u2192 4 \u2192 3 \u2192 2 \u2192 1\n    \"\"\"\n    result = text\n    \n    # TODO: Phase 5 \u2014 Reverse Wild Card (first!)\n    # result = phase5_decrypt(result, key)\n    \n    # TODO: Phase 4 \u2014 Reverse Noise Injection\n    # result = phase4_decrypt(result, key)\n    \n    # Phase 3: Reverse Password-Dependent\n    result = phase3_decrypt(result, key)\n    \n    # Phase 2: Reverse Transposition\n    result = phase2_decrypt(result, key)\n    \n    # Phase 1: Reverse Substitution (last!)\n    result = phase1_decrypt(result, key)\n    \n    return result\n```\n\n### Save the File"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 6: Test All Three Phases Together\n\n### Open Python REPL\n\n```bash\npython\n```\n\n### Test Full Pipeline\n\n```python\nfrom engine import encrypt, decrypt\nfrom engine import phase1_encrypt, phase2_encrypt, phase3_encrypt\n\n# Key with all settings\nkey = {\n    \"shift\": 7,          # Phase 1\n    \"block_size\": 4,     # Phase 2\n    \"password\": \"FORGE\"  # Phase 3\n}\n\nmessage = \"CipherForge 2026!\"\n\n# Watch each phase transform the message\nprint(f\"Original:       {message}\")\n\nafter_p1 = phase1_encrypt(message, key)\nprint(f\"After Phase 1:  {after_p1}\")\n\nafter_p2 = phase2_encrypt(after_p1, key)\nprint(f\"After Phase 2:  {after_p2}\")\n\nafter_p3 = phase3_encrypt(after_p2, key)\nprint(f\"After Phase 3:  {after_p3}\")\n\n# Full encrypt/decrypt\nencrypted = encrypt(message, key)\ndecrypted = decrypt(encrypted, key)\n\nprint(f\"\\nFull encrypt: {encrypted}\")\nprint(f\"Decrypted:    {decrypted}\")\nprint(f\"Success: {decrypted == message}\")\n```\n\n### Exit Python\n\n```python\nexit()\n```"
      }
    },
    {
      "type": "python",
      "title": "Three-Phase Test",
      "content": {
        "description": "Write code that:\n1. Creates a key with shift=10, block_size=5, password=\"CRYPTO\"\n2. Encrypts \"Three Phases!\"\n3. Decrypts the result\n4. Prints \"ALL PHASES WORKING\" if successful, \"BROKEN\" otherwise",
        "starter_code": "# All phase functions (already implemented)\ndef phase1_encrypt(text, key):\n    shift = key.get(\"shift\", 5)\n    result = \"\"\n    for char in text:\n        if 32 <= ord(char) <= 126:\n            position = ord(char) - 32\n            new_position = (position + shift) % 95\n            result += chr(new_position + 32)\n        else:\n            result += char\n    return result\n\ndef phase1_decrypt(text, key):\n    shift = key.get(\"shift\", 5)\n    result = \"\"\n    for char in text:\n        if 32 <= ord(char) <= 126:\n            position = ord(char) - 32\n            new_position = (position - shift) % 95\n            result += chr(new_position + 32)\n        else:\n            result += char\n    return result\n\ndef phase2_encrypt(text, key):\n    block_size = key.get(\"block_size\", 4)\n    result = \"\"\n    for i in range(0, len(text), block_size):\n        block = text[i:i + block_size]\n        result += block[::-1]\n    return result\n\ndef phase2_decrypt(text, key):\n    return phase2_encrypt(text, key)\n\ndef phase3_encrypt(text, key):\n    password = key.get(\"password\", \"SECRET\")\n    result = \"\"\n    for i, char in enumerate(text):\n        if 32 <= ord(char) <= 126:\n            password_char = password[i % len(password)]\n            password_shift = ord(password_char) % 95\n            position = ord(char) - 32\n            new_position = (position + password_shift) % 95\n            result += chr(new_position + 32)\n        else:\n            result += char\n    return result\n\ndef phase3_decrypt(text, key):\n    password = key.get(\"password\", \"SECRET\")\n    result = \"\"\n    for i, char in enumerate(text):\n        if 32 <= ord(char) <= 126:\n            password_char = password[i % len(password)]\n            password_shift = ord(password_char) % 95\n            position = ord(char) - 32\n            new_position = (position - password_shift) % 95\n            result += chr(new_position + 32)\n        else:\n            result += char\n    return result\n\ndef encrypt(text, key):\n    result = phase1_encrypt(text, key)\n    result = phase2_encrypt(result, key)\n    result = phase3_encrypt(result, key)\n    return result\n\ndef decrypt(text, key):\n    result = phase3_decrypt(text, key)\n    result = phase2_decrypt(result, key)\n    result = phase1_decrypt(result, key)\n    return result\n\n# YOUR TEST CODE HERE\nkey = # Create your key\nmessage = \"Three Phases!\"\n\n# Encrypt, decrypt, and verify\n",
        "hints": [
          "key = {\"shift\": 10, \"block_size\": 5, \"password\": \"CRYPTO\"}",
          "Use encrypt(message, key) and decrypt(result, key)",
          "Check if decrypted == message"
        ],
        "example_answer": "def phase1_encrypt(text, key):\n    shift = key.get(\"shift\", 5)\n    result = \"\"\n    for char in text:\n        if 32 <= ord(char) <= 126:\n            position = ord(char) - 32\n            new_position = (position + shift) % 95\n            result += chr(new_position + 32)\n        else:\n            result += char\n    return result\n\ndef phase1_decrypt(text, key):\n    shift = key.get(\"shift\", 5)\n    result = \"\"\n    for char in text:\n        if 32 <= ord(char) <= 126:\n            position = ord(char) - 32\n            new_position = (position - shift) % 95\n            result += chr(new_position + 32)\n        else:\n            result += char\n    return result\n\ndef phase2_encrypt(text, key):\n    block_size = key.get(\"block_size\", 4)\n    result = \"\"\n    for i in range(0, len(text), block_size):\n        block = text[i:i + block_size]\n        result += block[::-1]\n    return result\n\ndef phase2_decrypt(text, key):\n    return phase2_encrypt(text, key)\n\ndef phase3_encrypt(text, key):\n    password = key.get(\"password\", \"SECRET\")\n    result = \"\"\n    for i, char in enumerate(text):\n        if 32 <= ord(char) <= 126:\n            password_char = password[i % len(password)]\n            password_shift = ord(password_char) % 95\n            position = ord(char) - 32\n            new_position = (position + password_shift) % 95\n            result += chr(new_position + 32)\n        else:\n            result += char\n    return result\n\ndef phase3_decrypt(text, key):\n    password = key.get(\"password\", \"SECRET\")\n    result = \"\"\n    for i, char in enumerate(text):\n        if 32 <= ord(char) <= 126:\n            password_char = password[i % len(password)]\n            password_shift = ord(password_char) % 95\n            position = ord(char) - 32\n            new_position = (position - password_shift) % 95\n            result += chr(new_position + 32)\n        else:\n            result += char\n    return result\n\ndef encrypt(text, key):\n    result = phase1_encrypt(text, key)\n    result = phase2_encrypt(result, key)\n    result = phase3_encrypt(result, key)\n    return result\n\ndef decrypt(text, key):\n    result = phase3_decrypt(text, key)\n    result = phase2_decrypt(result, key)\n    result = phase1_decrypt(result, key)\n    return result\n\nkey = {\"shift\": 10, \"block_size\": 5, \"password\": \"CRYPTO\"}\nmessage = \"Three Phases!\"\n\nencrypted = encrypt(message, key)\ndecrypted = decrypt(encrypted, key)\n\nif decrypted == message:\n    print(\"ALL PHASES WORKING\")\nelse:\n    print(\"BROKEN\")",
        "test_cases": [
          {
            "input": "",
            "expected": "ALL PHASES WORKING"
          }
        ],
        "min_lines": 5,
        "must_differ_from_starter": true
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## \ud83d\udd22 Key Space: How Many Combinations?\n\nLet's calculate how hard it is to brute force your algorithm now!\n\n### Phase 1 Alone\n\n| Component | Options |\n|-----------|---------|\n| Shift value | 95 |\n| **Total** | **95** |\n\n### Phases 1-2\n\n| Component | Options |\n|-----------|---------|\n| Shift value | 95 |\n| Block size | ~20 |\n| **Total** | **1,900** |\n\n### Phases 1-3 with 6-character password\n\nFor the password, each character can be any of 95 printable ASCII characters:\n\n| Component | Options | Calculation |\n|-----------|---------|-------------|\n| Shift | 95 | 95 |\n| Block size | 20 | 20 |\n| Password (6 chars) | 95 per char | 95\u2076 = 735 billion |\n| **Total** | | **95 \u00d7 20 \u00d7 95\u2076** |\n\n```\n95 \u00d7 20 \u00d7 735,091,890,625 = 1.4 quadrillion combinations!\n```\n\nThat's **1,400,000,000,000,000** possible keys!"
      }
    },
    {
      "type": "mcq",
      "title": "Key Space Growth",
      "content": {
        "question": "If you increase the password length from 6 to 7 characters, how does the key space change?",
        "options": [
          "It increases by 95 (addition)",
          "It increases by 7 (one more character)",
          "It multiplies by 95 (exponential)",
          "It stays the same"
        ],
        "correct_index": 2,
        "explanation": "Each additional password character multiplies the key space by 95. Going from 6 to 7 characters: 95\u2076 \u00d7 95 = 95\u2077. The key space multiplied by 95! This exponential growth is why longer passwords are dramatically more secure than shorter ones."
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## \ud83e\uddee Calculate: Time to Crack\n\nLet's do some real math on how long brute force would take.\n\n### Assumptions\n\n- Computer tries **1 billion keys per second** (very fast!)\n- On average, attacker finds the key after trying **half** the possibilities\n\n### Phase 1 Only (95 keys)\n\n```\nTime = 95 \u00f7 2 \u00f7 1,000,000,000\n     = 0.0000000475 seconds\n     = Instant! \u274c\n```\n\n### Phases 1-2 (1,900 keys)\n\n```\nTime = 1,900 \u00f7 2 \u00f7 1,000,000,000\n     = 0.00000095 seconds\n     = Still instant! \u274c\n```\n\n### Phases 1-3 with 6-character password\n\n```\nKeys = 95 \u00d7 20 \u00d7 95\u2076 = 1.4 \u00d7 10\u00b9\u2075\nTime = 1.4\u00d710\u00b9\u2075 \u00f7 2 \u00f7 10\u2079 seconds\n     = 700,000 seconds\n     = 8 days \u2705\n```\n\n### With 8-character password\n\n```\nKeys = 95 \u00d7 20 \u00d7 95\u2078 = 1.26 \u00d7 10\u00b2\u2070\nTime = 1.26\u00d710\u00b2\u2070 \u00f7 2 \u00f7 10\u2079 seconds\n     = 63 trillion seconds\n     = 2 million years! \u2705\u2705\u2705\n```"
      }
    },
    {
      "type": "written_response",
      "title": "Key Space Calculation",
      "content": {
        "description": "Calculate the key space for YOUR current settings (shift: any 0-94, block_size: 2-20, password: pick a length). Show your math step by step. Then calculate approximately how long it would take to brute force at 1 billion attempts per second.",
        "example_answer": "My settings:\n- Shift: 95 options (0-94)\n- Block size: 19 options (2-20)\n- Password: 7 characters, 95 options each = 95\u2077\n\nTotal key space = 95 \u00d7 19 \u00d7 95\u2077\n                = 95 \u00d7 19 \u00d7 69,833,729,609,375\n                = 125,989,584,135,937,500\n                \u2248 1.26 \u00d7 10\u00b9\u2077\n\nTime to crack = 1.26\u00d710\u00b9\u2077 \u00f7 2 \u00f7 10\u2079\n              = 63,000,000 seconds\n              = 729 days\n              \u2248 2 years\n\nMy cipher would take about 2 years to brute force!",
        "min_words": 50,
        "max_words": 200
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Commit Checkpoint!\n\nPhase 3 is complete. Save your progress!\n\n### Commands\n\n```bash\ngit add .\ngit commit -m \"feature: implement Phase 3 password-based encryption\"\ngit push\n```\n\n### Verify on GitHub\n\n1. Refresh your repository page\n2. Click on `engine.py`\n3. You should see:\n   - `phase1_encrypt()` and `phase1_decrypt()`\n   - `phase2_encrypt()` and `phase2_decrypt()`\n   - `phase3_encrypt()` and `phase3_decrypt()` \u2728 NEW\n   - Updated `encrypt()` calling Phases 1, 2, and 3\n   - Updated `decrypt()` calling Phases 3, 2, then 1"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Current engine.py Structure\n\nYour file should now look like this:\n\n```python\n\"\"\"\nCipherForge \u2014 Encryption Engine\n================================\n... (header) ...\n\"\"\"\n\n# ==================== PHASE 1: SUBSTITUTION ====================\ndef phase1_encrypt(text, key): ...\ndef phase1_decrypt(text, key): ...\n\n# ==================== PHASE 2: TRANSPOSITION ====================\ndef phase2_encrypt(text, key): ...\ndef phase2_decrypt(text, key): ...\n\n# ==================== PHASE 3: PASSWORD-DEPENDENT ====================\ndef phase3_encrypt(text, key): ...  # NEW!\ndef phase3_decrypt(text, key): ...  # NEW!\n\n# ==================== MASTER FUNCTIONS ====================\ndef encrypt(text, key):\n    result = phase1_encrypt(text, key)  # Phase 1\n    result = phase2_encrypt(result, key)  # Phase 2\n    result = phase3_encrypt(result, key)  # Phase 3\n    # TODO: Phases 4-5\n    return result\n\ndef decrypt(text, key):\n    result = phase3_decrypt(text, key)  # Phase 3 first!\n    result = phase2_decrypt(result, key)  # Phase 2\n    result = phase1_decrypt(result, key)  # Phase 1 last!\n    return result\n```"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## \u2705 Checklist: Before Moving On\n\n- [ ] Added `phase3_encrypt()` with password-based shifting\n- [ ] Added `phase3_decrypt()` (subtracts instead of adds)\n- [ ] Updated `encrypt()` to call Phases 1, 2, then 3\n- [ ] Updated `decrypt()` to call Phases 3, 2, then 1 (reverse order!)\n- [ ] Tested Phase 3 alone in REPL\n- [ ] Tested all three phases combined\n- [ ] Verified wrong password produces garbage\n- [ ] Calculated your key space size\n- [ ] Committed with message: `feature: implement Phase 3 password-based encryption`\n- [ ] Pushed to GitHub\n\n> \ud83c\udfaf **Phase 3 Complete!** Your algorithm now has three layers and potentially **quadrillions** of possible keys. In the next lesson, you'll add Phases 4 (Noise Injection) and 5 (Wild Card) to complete your 5-layer encryption system!"
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Summary\n\n| Topic | Key Points |\n|-------|------------|\n| **Fixed vs Key-Dependent** | Without password, same input = same output |\n| **Password Cycling** | `password[i % len(password)]` repeats the password |\n| **Variable Shift** | Each position gets different shift from password |\n| **Wrong Password** | Produces garbage, not the original message |\n| **Key Space** | Password multiplies possibilities exponentially |\n| **Time to Crack** | Longer passwords = exponentially longer crack time |\n\n---\n\n### Code Progress\n\n| Function | Status |\n|----------|--------|\n| `phase1_encrypt()` | \u2705 Complete |\n| `phase1_decrypt()` | \u2705 Complete |\n| `phase2_encrypt()` | \u2705 Complete |\n| `phase2_decrypt()` | \u2705 Complete |\n| `phase3_encrypt()` | \u2705 Complete |\n| `phase3_decrypt()` | \u2705 Complete |\n| `phase4_encrypt()` | \ud83d\udd32 Next lesson |\n| `phase4_decrypt()` | \ud83d\udd32 Next lesson |\n| `phase5_encrypt()` | \ud83d\udd32 Next lesson |\n| `phase5_decrypt()` | \ud83d\udd32 Next lesson |\n| `encrypt()` | \u26a0\ufe0f Phases 1-3 |\n| `decrypt()` | \u26a0\ufe0f Phases 1-3 |\n\n**Next Up**: Lesson 6 \u2014 Complete your algorithm with Phase 4 (Noise Injection) and Phase 5 (Wild Card \u2014 your own invention)!"
      }
    }
  ]
}
