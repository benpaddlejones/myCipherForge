{
  "id": "testing-and-documentation",
  "title": "Testing and Documentation",
  "sections": [
    {
      "type": "markdown",
      "content": {
        "text": "# Lesson 8: Testing and Documentation\n\n### Learning Objectives\n\nBy the end of this lesson, you will:\n\n- Create a comprehensive test file for your algorithm\n- Write unit tests that verify each phase\n- Complete your README documentation\n- Understand what makes an algorithm \"production-ready\"\n\n---\n\n## Why Testing Matters\n\nRight now, you test your algorithm manually in the REPL. But what happens when:\n\n- You change Phase 3 and accidentally break Phase 1?\n- Someone else wants to use your code - how do they know it works?\n- You come back in 6 months - does it still work?\n\n**Automated tests** solve all of these by running checks automatically.\n\n---\n\n## Step 1: Create the Test File\n\n**Create a new file `test_engine.py`** in your project root:\n\n```python\n\"\"\"Test suite for CipherForge encryption algorithm.\n\nRun with: python test_engine.py\n\"\"\"\n\nfrom engine import (\n    phase1_encrypt, phase1_decrypt,\n    phase2_encrypt, phase2_decrypt,\n    phase3_encrypt, phase3_decrypt,\n    phase4_encrypt, phase4_decrypt,\n    phase5_encrypt, phase5_decrypt,\n    encrypt, decrypt\n)\n\n\ndef test_phase1():\n    \"\"\"Test Phase 1: Caesar shift.\"\"\"\n    key = {\"shift\": 5}\n    \n    # Test encryption\n    original = \"Hello\"\n    encrypted = phase1_encrypt(original, key)\n    assert encrypted != original, \"Phase 1 should change the text\"\n    \n    # Test decryption reverses encryption\n    decrypted = phase1_decrypt(encrypted, key)\n    assert decrypted == original, f\"Phase 1 decrypt failed: got {decrypted}\"\n    \n    print(\"\u2705 Phase 1 tests passed\")\n\n\ndef test_phase2():\n    \"\"\"Test Phase 2: Block reversal.\"\"\"\n    key = {\"block_size\": 4}\n    \n    original = \"ABCDEFGH\"\n    encrypted = phase2_encrypt(original, key)\n    \n    # Block reversal should rearrange characters\n    assert encrypted != original, \"Phase 2 should change the text\"\n    \n    # Decryption should restore original\n    decrypted = phase2_decrypt(encrypted, key)\n    assert decrypted == original, f\"Phase 2 decrypt failed: got {decrypted}\"\n    \n    print(\"\u2705 Phase 2 tests passed\")\n\n\ndef test_phase3():\n    \"\"\"Test Phase 3: Password-based variable shift.\"\"\"\n    key = {\"password\": \"SECRET\"}\n    \n    original = \"Test message\"\n    encrypted = phase3_encrypt(original, key)\n    \n    assert encrypted != original, \"Phase 3 should change the text\"\n    \n    decrypted = phase3_decrypt(encrypted, key)\n    assert decrypted == original, f\"Phase 3 decrypt failed: got {decrypted}\"\n    \n    print(\"\u2705 Phase 3 tests passed\")\n\n\ndef test_phase4():\n    \"\"\"Test Phase 4: Noise injection.\"\"\"\n    key = {\"noise_interval\": 3, \"noise_char\": \"~\"}\n    \n    original = \"ABCDEF\"\n    encrypted = phase4_encrypt(original, key)\n    \n    # Noise injection should make text longer\n    assert len(encrypted) > len(original), \"Phase 4 should add characters\"\n    \n    decrypted = phase4_decrypt(encrypted, key)\n    assert decrypted == original, f\"Phase 4 decrypt failed: got {decrypted}\"\n    \n    print(\"\u2705 Phase 4 tests passed\")\n\n\ndef test_phase5():\n    \"\"\"Test Phase 5: Your wild card.\"\"\"\n    key = {}  # Phase 5 may or may not use key\n    \n    original = \"Wild card test\"\n    encrypted = phase5_encrypt(original, key)\n    \n    decrypted = phase5_decrypt(encrypted, key)\n    assert decrypted == original, f\"Phase 5 decrypt failed: got {decrypted}\"\n    \n    print(\"\u2705 Phase 5 tests passed\")\n\n\ndef test_full_pipeline():\n    \"\"\"Test all 5 phases combined.\"\"\"\n    key = {\n        \"shift\": 7,\n        \"block_size\": 5,\n        \"password\": \"TESTKEY\",\n        \"noise_interval\": 4,\n        \"noise_char\": \"$\"\n    }\n    \n    test_messages = [\n        \"Hello World!\",\n        \"CipherForge 2026\",\n        \"The quick brown fox\",\n        \"abc123!@#\",\n        \"A\",\n        \"AB\"\n    ]\n    \n    for message in test_messages:\n        encrypted = encrypt(message, key)\n        decrypted = decrypt(encrypted, key)\n        assert decrypted == message, f\"Pipeline failed for '{message}': got '{decrypted}'\"\n    \n    print(\"\u2705 Full pipeline tests passed\")\n\n\ndef test_different_keys():\n    \"\"\"Test that different keys produce different results.\"\"\"\n    key1 = {\"shift\": 5, \"block_size\": 4, \"password\": \"KEY1\", \"noise_interval\": 3, \"noise_char\": \"~\"}\n    key2 = {\"shift\": 10, \"block_size\": 6, \"password\": \"KEY2\", \"noise_interval\": 4, \"noise_char\": \"#\"}\n    \n    message = \"Same message\"\n    \n    encrypted1 = encrypt(message, key1)\n    encrypted2 = encrypt(message, key2)\n    \n    assert encrypted1 != encrypted2, \"Different keys should produce different ciphertext\"\n    \n    # But each should still decrypt correctly with its own key\n    assert decrypt(encrypted1, key1) == message\n    assert decrypt(encrypted2, key2) == message\n    \n    print(\"\u2705 Different keys test passed\")\n\n\ndef run_all_tests():\n    \"\"\"Run all test functions.\"\"\"\n    print(\"=\"*60)\n    print(\"CIPHERFORGE TEST SUITE\")\n    print(\"=\"*60)\n    \n    test_phase1()\n    test_phase2()\n    test_phase3()\n    test_phase4()\n    test_phase5()\n    test_full_pipeline()\n    test_different_keys()\n    \n    print(\"=\"*60)\n    print(\"\ud83c\udf89 ALL TESTS PASSED!\")\n    print(\"=\"*60)\n\n\nif __name__ == \"__main__\":\n    run_all_tests()\n```"
      }
    },
    {
      "type": "mcq",
      "title": "Assert Statement",
      "content": {
        "question": "What does `assert decrypted == original` do in a test?",
        "options": [
          "It prints the values of both variables",
          "It raises an error if decrypted does NOT equal original",
          "It assigns original to decrypted",
          "It encrypts the original value"
        ],
        "correct_index": 1,
        "explanation": "The assert statement checks if a condition is True. If `decrypted == original` is False, Python raises an AssertionError and the test fails. This is how we verify that our functions work correctly \u2014 we assert what SHOULD be true, and the test fails if it's not."
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 2: Run the Test Suite\n\nRun your tests:\n\n```bash\npython test_engine.py\n```\n\nExpected output if everything works:\n\n```\n============================================================\nCIPHERFORGE TEST SUITE\n============================================================\n\u2705 Phase 1 tests passed\n\u2705 Phase 2 tests passed\n\u2705 Phase 3 tests passed\n\u2705 Phase 4 tests passed\n\u2705 Phase 5 tests passed\n\u2705 Full pipeline tests passed\n\u2705 Different keys test passed\n============================================================\n\ud83c\udf89 ALL TESTS PASSED!\n============================================================\n```\n\n**If a test fails**: The error message tells you which phase broke and what went wrong. Fix the bug in `engine.py`, then run tests again."
      }
    },
    {
      "type": "written_response",
      "title": "Run Tests",
      "content": {
        "description": "Run `python test_engine.py` and paste the output. Did all tests pass? If any failed, explain what the error was and how you fixed it.",
        "example_answer": "============================================================\nCIPHERFORGE TEST SUITE\n============================================================\n\u2705 Phase 1 tests passed\n\u2705 Phase 2 tests passed\n\u2705 Phase 3 tests passed\n\u2705 Phase 4 tests passed\n\u2705 Phase 5 tests passed\n\u2705 Full pipeline tests passed\n\u2705 Different keys test passed\n============================================================\n\ud83c\udf89 ALL TESTS PASSED!\n============================================================\n\nAll tests passed on first run!",
        "min_words": 30
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 3: Complete Your README\n\nYour README is the first thing people see when they visit your repository.\n\n**Update `README.md`** with complete documentation:\n\n```markdown\n# \ud83d\udd10 CipherForge\n\nA 5-phase encryption algorithm built from scratch in Python.\n\n## \ud83d\udccb Description\n\nCipherForge is an educational encryption system that demonstrates how real-world encryption algorithms like AES work. It applies 5 layers of transformation to convert plaintext into unreadable ciphertext.\n\n## \u2728 Features\n\n- **5-phase encryption pipeline**\n- **Web interface** for easy encryption/decryption\n- **Key-based security** with trillions of combinations\n- **Automated test suite** for verification\n\n## \ud83d\udd27 The 5 Phases\n\n| Phase | Name | Description |\n|-------|------|-------------|\n| 1 | Substitution | Shifts all characters by a fixed amount |\n| 2 | Transposition | Reverses characters in blocks |\n| 3 | Key-Dependent | Uses password for variable shifting |\n| 4 | Noise Injection | Adds decoy characters |\n| 5 | Wild Card | [YOUR DESCRIPTION HERE] |\n\n## \ud83d\ude80 Getting Started\n\n### Run in Codespaces\n\n1. Click **Code** \u2192 **Codespaces** \u2192 **Create codespace**\n2. Wait for environment to load\n3. Run: `python app.py`\n4. Open the Ports tab and click the globe icon for port 5000\n\n### Run Tests\n\n```bash\npython test_engine.py\n```\n\n## \ud83d\udd11 Key Format\n\nThe encryption key is a dictionary with these fields:\n\n```python\nkey = {\n    \"shift\": 5,              # Phase 1: shift amount (1-94)\n    \"block_size\": 4,         # Phase 2: block size (2-20)\n    \"password\": \"SECRET\",    # Phase 3: encryption password\n    \"noise_interval\": 3,     # Phase 4: insert noise every N chars\n    \"noise_char\": \"~\"        # Phase 4: noise character to insert\n}\n```\n\n## \ud83d\udcca Security Analysis\n\n### Strengths\n\n- Multi-layer encryption defeats simple attacks\n- Password-based encryption provides large key space\n- Noise injection defeats frequency analysis\n\n### Weaknesses (Educational Context)\n\n- Not mathematically proven like AES\n- Smaller key space than production encryption\n- Vulnerable to known-plaintext attacks with enough samples\n\n## \ud83d\udcdd License\n\nMIT License - see [LICENSE](LICENSE) file\n\n## \ud83d\udc64 Author\n\n[YOUR NAME] - [YOUR SCHOOL] - 2026\n\n---\n\n*Built as part of Year 9 Digital Technologies*\n```"
      }
    },
    {
      "type": "mcq",
      "title": "README Purpose",
      "content": {
        "question": "Why is a well-written README important for a software project?",
        "options": [
          "It makes the code run faster",
          "It helps others understand, install, and use your project",
          "It prevents hackers from accessing your code",
          "It automatically generates documentation"
        ],
        "correct_index": 1,
        "explanation": "The README is the first thing visitors see. A good README explains what the project does, how to install and run it, and how to use it. This helps collaborators, users, teachers, and even your future self understand the project without reading all the code."
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 4: Add Your Phase 5 Description\n\nEdit the README and replace `[YOUR DESCRIPTION HERE]` with a description of YOUR Phase 5. Be specific about what it does!\n\nExamples:\n\n- \"Swaps adjacent character pairs\"\n- \"Alternates forward/backward shifts by position\"\n- \"Reverses the entire message\"\n- \"Applies XOR transformation with fixed value\""
      }
    },
    {
      "type": "written_response",
      "title": "README Phase 5",
      "content": {
        "description": "What description did you write for your Phase 5 in the README? Write the exact text you added to the table.",
        "example_answer": "Phase 5: Pair Swap - Swaps every two adjacent characters (ABCD \u2192 BADC)",
        "min_words": 5
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "## Step 5: Final Code Review Checklist\n\nBefore submitting, verify your project meets these standards:\n\n### Code Quality \u2713\n\n- [ ] All functions have docstrings explaining what they do\n- [ ] Variable names are descriptive (`encrypted_text` not `x`)\n- [ ] No hardcoded magic numbers (use key dictionary values)\n- [ ] Code is properly indented and formatted\n\n### Functionality \u2713\n\n- [ ] All 5 phases encrypt AND decrypt correctly\n- [ ] Master `encrypt()` and `decrypt()` call all phases\n- [ ] Decryption reverses encryption in correct order\n- [ ] All tests pass (`python test_engine.py`)\n\n### Web Interface \u2713\n\n- [ ] Home page displays correctly\n- [ ] Workshop encrypts messages\n- [ ] Workshop decrypts with same key\n- [ ] All key inputs work (shift, block_size, password, noise)\n\n### Documentation \u2713\n\n- [ ] README explains the project\n- [ ] README has installation instructions\n- [ ] Phase 5 description is YOUR implementation\n- [ ] License file exists (MIT)\n- [ ] Author name filled in"
      }
    },
    {
      "type": "mcq",
      "title": "Docstring Purpose",
      "content": {
        "question": "What is the purpose of a docstring in Python?",
        "options": [
          "To make the code run faster",
          "To encrypt the function's code",
          "To document what a function does for future readers",
          "To prevent others from using the function"
        ],
        "correct_index": 2,
        "explanation": "A docstring is a string at the beginning of a function that documents what it does, its parameters, and return value. It helps future readers (including yourself!) understand the code without having to read every line. Good documentation is a sign of professional-quality code."
      }
    },
    {
      "type": "markdown",
      "content": {
        "text": "---\n\n## Checkpoint: Final Commit\n\n```bash\ngit add -A\ngit commit -m \"feat: Add test suite and complete documentation\"\ngit push\n```\n\n---\n\n## Final Project Structure\n\nYour complete CipherForge project:\n\n```\nCipherForge/\n\u251c\u2500\u2500 .devcontainer/\n\u2502   \u2514\u2500\u2500 devcontainer.json\n\u251c\u2500\u2500 .github/\n\u2502   \u2514\u2500\u2500 copilot-instructions.md\n\u251c\u2500\u2500 templates/\n\u2502   \u251c\u2500\u2500 base.html\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 workshop.html\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 engine.py\n\u251c\u2500\u2500 test_engine.py\n\u251c\u2500\u2500 LICENSE\n\u2514\u2500\u2500 README.md\n```\n\n---\n\n## What You've Accomplished \ud83c\udf89\n\nCongratulations! You've built a complete encryption system from scratch:\n\n| Component | What You Built |\n|-----------|----------------|\n| **Algorithm** | 5-phase encryption with substitution, transposition, key-dependence, noise, and your wild card |\n| **Key Space** | Over 10\u00b2\u2070 possible key combinations |\n| **Web Interface** | Flask app with encrypt/decrypt forms |\n| **Testing** | Automated test suite verifying all phases |\n| **Documentation** | Professional README and code comments |\n\n### Skills You Developed\n\n- **Python**: Functions, loops, string manipulation, modular arithmetic\n- **Flask**: Routes, templates, forms, HTTP methods\n- **Cryptography**: Substitution, transposition, key-dependence, frequency analysis\n- **Testing**: Assert statements, unit tests, edge cases\n- **Git**: Commits, pushing, collaboration workflow\n- **Documentation**: README, docstrings, code comments\n\n### Real-World Connection\n\nYour algorithm demonstrates the same principles used by:\n\n- **AES**: The encryption protecting banks, governments, and your browser\n- **TLS/HTTPS**: The lock icon securing every website\n- **Signal/WhatsApp**: End-to-end encrypted messaging\n\nYou now understand HOW encryption works, not just that it exists!\n\n---\n\n## Next Steps: Extensions (Optional)\n\nIf you want to challenge yourself further, continue to the **Extensions** lesson where you'll:\n\n- Add basic username/password authentication\n- Write pytest tests that verify algorithms without knowing their internals\n\n---\n\n## \ud83d\udd10 You Are Now a CipherForge Engineer! \ud83d\udd10\n\nYour encryption algorithm works. You tested it. You documented it. You deployed it.\n\nThat's real software engineering."
      }
    }
  ]
}